# Randomness and Noise

Random numbers play a major role in procedural terrain generation and many other dynamically created content in the game. There are different random number generators and different types of noise.

## Random Numbers

There are two implementations of the `Random` interface: `FastRandom` and `MersenneRandom`. As you might expect, the first one is rather simplistic, which makes it very fast. In some cases, the quality is not sufficient though and we recommend the implementation that is based on the Mersenne prime number twister. It is very close to *real* noise, but more expensive to compute.

**Rule of thumb:** Use `MersenneRandom` when looking at very small value ranges (e.g. floats between 0 and 0.000001 or boolean values), FastRandom otherwise.


## Noise

Noise generators are similar to random number generators, but provide a deterministic value per coordinate in space. 

The `PerlinNoise` and `SimplexNoise` classes assign random gradient in a regular grid (Perlin uses squares/cubes, Simplex uses triangles/tetrahedrons) and interpolate in between. Simplex is a bit faster than Perlin, in particular for higher dimensions at comparable noise quality. Noise is isotropic (looks the same independent from direction or position).

The `BrownianNoise` class integrates values from other noise implementations. This allows for adjustment of noise frequencies. For example, different layers of Perlin noise can be put on top of each other at different spatial scales and at different amplitudes. This gives the prominent Perlin noise textures.

The `FastNoise` class is a bit different as it works on discrete numbers. This is good enough for per-block noise values. It is about 2x faster than SimplexNoise and 5x faster than PerlinNoise. Noise values repeat after 256, i.e. noise(256) is equal to noise(0).

**Rule of thumb:** Use `SimplexNoise` whenever possible. Noise that is required per block can also be computed using `FastNoise`.

![An overview over different noise implementations](https://cloud.githubusercontent.com/assets/1820007/5960183/f31d5402-a7d3-11e4-90f3-6bee10c7d2ce.png)

*Originally added at https://github.com/MovingBlocks/Terasology/wiki/Randomness-and-Noise*

For terrain generation, the brigther the area, the higher the elevation. The brighter, the higher the random numbers at that area.

### How does the noise work?

In procedural generation, noise is important to generate a terrain. In this tutorial, we use `SimplexNoise` to generate a simple terrain with some rolling hills. `SimplexNoise` works similar to `PerlinNoise` but with faster performance. Below is a graph which represents the random values generated using Perlin Noise. We use these random values to further building up world and terrain.

![Perlin Noise Graph](https://raw.githubusercontent.com/PutawanDE/TutorialWorldGeneration/noiseWiki/images/Noise/perlinNoiseGraph.png)

`PerlinNoise` works by generating a random number between -1 and 1 which is related to the previous and next random numbers. As you can see the line is smooth, that means the differences between each random values are not much. This can help to create a smoother and more organic terrain.

For even more realistic terrain, we can overlay multiple noise maps over each other using `BrownianNoise`. We can adjust noise frequencies, spatial scales and amplitudes of each different overlaying noise maps. In this tutorial, this technic is used to create mountains.

You can think like the noise behaves like a wave with a bunch of random numbers along. It has frequency, amplitude and wavelength.
### Applying Noise

Some of the following terrains are already covered in this tutorial - from [Noise Sampling](Noise-Sampling) and [Facet Modification](Facet-Modification).

**Simple**

![Simplex Noise](https://raw.githubusercontent.com/PutawanDE/TutorialWorldGeneration/noiseWiki/images/Noise/simplex.png)
Th above is a terrain (rolling hills) generated using `SimplexNoise`. Code sample:
```java
@Override
public void setSeed(long seed) {
    terrainNoise = new SubSampledNoise(new SimplexNoise(seed), new Vector2f(0.01f, 0.01f), 1);
}
```
The noise generates random numbers between -1 and 1. We get this result by scale up (multiply) the random numbers and use them  to set world. We also use `SubsampledNoise` to smooth out the terrain by gradually get to various noise values - lerping between them. As you can see, we have a lot of parameters set in `SubSampledNoise`. We will discuss this later with examples.

**Noise Map Overlaying**

![Browninan Noise Perline](https://raw.githubusercontent.com/PutawanDE/TutorialWorldGeneration/noiseWiki/images/Noise/brownianPerlin.png)
This is a terrain generated by overlaying the first terrain `SimplexNoise` and `BrownianNoise(PerlinNoise)`.

```java
@Override
public void setSeed(long seed) {
    terrainNoise = new SubSampledNoise(new BrownianNoise(new PerlinNoise(seed + 2), 8), new Vector2f(0.001f, 0.001f), 1);
}
```
 We overlay this noise map `BrownianNoise(PerlinNoise)` and `simplexNoise` map - from the first one - in order to get a more interesting terrain.
 
We use `seed + 2` because we want a different noise map. And same as the first terrain, we multiple the random numbers to get high mountains. `BrownianNoise` and its parameters will be discussed further.

**SubSampledNoise**

This is used to gradually get various noise values - lerping between them to create smoother terrain. Let's take a look at `SubSampledNoise` for both terrains - its parameters and their usages.
```java
SubSampledNoise(Noise source, Vector3f zoom, int sampleRate)
```
The `source` is the noise generator. For example in the second terrain, we use `new BrownianNoise(new PerlinNoise(seed + 2), 8)`. The `zoom` is `0.001f, 0.001f, 1f` - default value for z axis is 1 as noise map is 2D. The `sampleRate` is `1`. 

Now some of you might wander "What is `Vector3f zoom` used for?". The `zoom` is used to zoom in/out the noise map and adjusting noise's frequency. Let's look at some examples - we still use mountain terrains as examples for clearer images.

![NoiseMapZoom0.001](https://raw.githubusercontent.com/PutawanDE/TutorialWorldGeneration/noiseWiki/images/Noise/NoiseMapZoom0.001.png)

*The above is the Noise Map for the second terrain which uses `0.001f, 0.001f, 1f` as `zoom`.*

![NoiseMapZoom0.01](https://raw.githubusercontent.com/PutawanDE/TutorialWorldGeneration/noiseWiki/images/Noise/NoiseMapZoom0.01.png)

*This is the Noise Map of a terrain which uses `0.01f, 0.01f, 1f` as `zoom`.*

As you can see, the first Noise Map is like a zoom in version of the second one - bigger bright and dark area. The second one has smaller and more bright and dark area. That means in the same given area, the second one will produce more mountains but with fewer details.

![TerrainNoiseZoom0.01](https://raw.githubusercontent.com/PutawanDE/TutorialWorldGeneration/noiseWiki/images/Noise/NoiseZoom0.01.png)

This is the terrain generated by the second Noise Map. It is nice. The difference between the two is the mountains here are smaller and steeper than the first one because of more bright and dark area per the same given area. More frequency, less wavelength, same amplitude.

The result can be extreme. Below is a terrain which uses `0.1f, 0.1f, 1f` as `zoom`. More frequency, less wavelength, same amplitude.

![TerrainNoiseZoom](https://raw.githubusercontent.com/PutawanDE/TutorialWorldGeneration/noiseWiki/images/Noise/NoiseZoom0.1.png)
*There are a lot of mountains and peaks in this picture more than any others in this page combined.*

You can play around with the `zoom` in the configuration menu. Ratio of 1 has the `zoom` of 0.01f, lowest is 0.1f with `zoom` of 0.001f.

**BrownianNoise**

```java
BrownianNoise(Noise other, int octaves)
```

For `BrownianNoise`, in this tutorial, we use it to create mountains. We use it to overlay different layers of noise and adjust its octave. In the mountains terrain, the `other` is set to `new PerlinNoise(seed + 2)`. The octave here is `8`. Let's change it to 2 and see what will happen?

![TerrainOctave2](https://raw.githubusercontent.com/PutawanDE/TutorialWorldGeneration/noiseWiki/images/Noise/brownianPerlinOctave4.png)

The mountains are more rounded and also the gap (valley) between each one are wider. Less octave, more spread mountains.

![TerrainOctave8](https://raw.githubusercontent.com/PutawanDE/TutorialWorldGeneration/noiseWiki/images/Noise/brownianPerlinOctave8.png)

Octave 2 vs. Octave 8. Same position.

**White Noise**

In this tutorial, White Noise is used to place houses. This noise is commonly used for trees, plants and flora, generated and placed on the terrain. The Core Module also uses White Noise to generate trees and flora on the terrain.

```java
@Override
public void setSeed(long seed) {
    treesNoise = new WhiteNoise(seed);
}
``` 
Below is the example terrain with trees generated using White Noise. The tree generator is also in this tutorial repo.

![WhiteNoiseTrees](https://raw.githubusercontent.com/PutawanDE/TutorialWorldGeneration/noiseWiki/images/Noise/whiteNoise2.png)

The trees are scattered, like naturally. To achieve this, we place the tree's trunk (center) at the point where random number generated by White Noise is more than 0.99.

We can get the random numbers at each coordinates in the noise map. `wx` is the x coordinate of the world region. `wz` is the y coordinate. It is `wz` because the noise map is 2D as y coordinate represents the height.
```java
@Override
public void process(GeneratingRegion region) {
    Border3D border = region.getBorderForFacet(TreesFacet.class).extendBy(0, 7, 1);
    TreesFacet facet = new TreesFacet(region.getRegion(), border);

    SurfaceHeightFacet surfaceHeightFacet = region.getRegionFacet(SurfaceHeightFacet.class);
    Rect2i worldRegion = surfaceHeightFacet.getWorldRegion();

    for (int wz = worldRegion.minY(); wz <= worldRegion.maxY(); wz++) {
        for (int wx = worldRegion.minX(); wx <= worldRegion.maxX(); wx++) {
            int surfaceHeight = TeraMath.floorToInt(surfaceHeightFacet.getWorld(wx, wz));

            // check if height is within this region
            if (surfaceHeight >= facet.getWorldRegion().minY() &&
                    surfaceHeight <= facet.getWorldRegion().maxY()) {

                if (treesNoise.noise(wx, wz) > 0.99) {
                    facet.setWorld(wx, surfaceHeight, wz, new Tree());
                }
            }
        }
    }

    region.setRegionFacet(TreesFacet.class, facet);
}
```
We compare if that random number at the specific coordinate is more than 0.99, then we place a tree. This is also the logic used for houses in this tutorial.

As you can see, we don't need `SubSampledNoise` because we don't use all random numbers to do anything - like placing blocks. We need some of them to place trees.

This terrain works almost the same as houses, covered in this tutorial. This is only to show how White Noise can help to achieve natural vegetations.

**Summary**

`PerlinNoise`, `SimplexNoise`: use to create simple, organic terrain. **It's best to use Simplex Noise as it is faster.**

`BrownianNoise(PerlinNoise)`, `BrownianNoise(SimplexNoise)`: use to create more complex, organic terrain by overlaying different layers of noise.

`BrownianNoise(Noise)`: use to overlay different layers of noise to get more complex result

`WhiteNoise`: use for vegetations

`SubSampledNoise`: use to get smoother terrain by gradually get to various random values

